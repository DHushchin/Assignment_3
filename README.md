# Assignment #3. Data structures
## Варіант #1. Пошук найкоротшого шляху
Знайти в заданому лабіринті найкоротший шлях між двома точками за допомогою алгоритму Дейкстри.  Щоб написати цей алгоритм, треба скористатися структурою даних queue (черга), яку треба написати власноруч.

*Складніше завдання (+1 бал):* Реалізувати [алгоритм А\*](https://en.wikipedia.org/wiki/A*_search_algorithm) з простою пріоритетною чергою – без написання binary heap. 

### Вхідні та вихідні дані
Вхідний лабіринт задається у файлі форматованою двовимірною матрицею. В коді задається точка початку пошуку шляху та кінцева точка. Приклад вхідних даних:
```
X X X X X X X X   
X       X X   X   
X   X   X X   X   
X   X         X   
X   X   X   X X     
X   X   X   X X   
X   X       X X   
X X X X X X X X 
```
Вивід – візуалзіація роботи алгоритму (у файл або на екран)
```
X X X X X X X X   
X 5 6 7 X X e X   
X 4 X 8 X X d X   
X 3 X 9 a b c X   
X 2 X   X   X X    
X 1 X   X   X X  
X   X       X X  
X X X X X X X X  
```
## Питання та необхідні знання
Третя робота знайомить вас із імплементацією структур даних, які надалі використовуватимуться у більшості програм, які ви будете писати. В цій лабораторній для успішної здачі вам треба буде відповісти на кілька теоретичних питань. Отже для повноцінної здачі вам треба: 
* Знати, що таке О-велике і для чого воно використовується.
* Розуміти, чому алгоритми та структури, запропоновані в цій роботі, мають ту чи іншу асимптотичну складність *(вивчити напам'ять не значить зрозуміти, для здачі треба буде відповісти на питання чому певні алгоритми або структури мають **саме таку** складність, а не яку вони мають складність)*.
* Мати уявлення, в яких випадках краще використовувати одні структури, а в яких – інші.
* Розбиратися в структурах stack, queue, priority queue, linked list, doubly linked list, hash table.
* Пошук шляху у графі, алгоритм Дейкстри та A\*
* Мати поняття, що таке евристика (посилання є нижче, в варіанті №1)
* Розуміти, як працює і яке завдання у хеш-функцій *(зауважте, що існують також криптографічні хеш-функції, які не мають відношення до цієї роботи; якщо ви читаєте статтю про хеші і часто зустрічаєте слова "md5", "sha", "bcrypt", "криптографія" – ви читаєте не те, що треба)*

### Посилання

* [Евристика](http://gamedev.stackexchange.com/questions/61850/in-a-star-how-does-the-heuristic-help-determine-your-path) в алгоритмах пошуку шляху в іграх
* [Нормальний](http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html) опис евристики в A\* від хлопців зі Стенфорду. Рекомендую почитати весь цикл
* [Алгоритм А\*](https://en.wikipedia.org/wiki/A*_search_algorithm)
* [Бінарна купа](https://en.wikipedia.org/wiki/Binary_heap) – використовується як швидка пріоритетна черга в A\*, проте ще раз наголошую, в цій лабораторній роботі її писати не треба
* [Пошук шляху](https://en.wikipedia.org/wiki/Pathfinding)

Пошук шляху дуже часто використовується для [трасування електричних плат](https://en.wikipedia.org/wiki/Routing_(electronic_design_automation)); для маршрутизації пакетів у [комп'ютерних мережах](https://en.wikipedia.org/wiki/Routing); для написання [AI в іграх](https://arongranberg.com/astar/). Черги та пріоритетні черги використовуються в ОС для контролю [доступу до ресурсів](https://github.com/torvalds/linux/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/prio_heap.h); для [імплементації](https://github.com/torvalds/linux/blob/master/include/linux/plist.h) м'ютексів та черги виконання процесів; в іграх та 3D-програмах для [рендерингу місцевості (terrain)](https://en.wikipedia.org/wiki/ROAM); в алгоритмах стискання зображень/музики/файлів – [кодування Хаффмана](https://en.wikibooks.org/wiki/JPEG_-_Idea_and_Practice/The_Huffman_coding).

*\*Написання алгоритму Дейкстри/A\* та черги є обов'язковою умовою для здачі цього варіанту*
